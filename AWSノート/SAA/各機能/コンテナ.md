# 🔹 コンテナの概念

## 1️⃣ コンテナとは？

- アプリケーションとその実行環境（ライブラリ・依存関係）を「ひとまとまり」にしてパッケージ化したもの。
    
- **軽量でポータブルな実行単位**。
    
- OSのカーネルを共有するため、仮想マシン（VM）より効率的。
    

👉 よく使われるコンテナ技術の代表例が **Docker**。

---

## 2️⃣ 仮想マシン（VM）との違い

|項目|仮想マシン (VM)|コンテナ|
|---|---|---|
|**構造**|ハイパーバイザー上で「ゲストOSごと」動作|ホストOSのカーネルを共有し、アプリ＋依存関係のみを分離|
|**サイズ**|数GB（OS込み）|数十MB〜数百MB|
|**起動時間**|数分|数秒以下|
|**効率**|重い（OSが複数稼働するため）|軽量（カーネルを共有）|
|**移植性**|ゲストOS依存がある|どこでも同じ環境で実行可能|

---

## 3️⃣ コンテナの特徴

- **ポータビリティ（移植性）**  
    → どの環境（開発PC・テスト環境・本番AWSなど）でも同じ動作
    
- **軽量・高速起動**  
    → OSを含まないので秒単位で起動可能
    
- **スケーラブル**  
    → 大量のコンテナを同時に起動して負荷分散が容易
    
- **分離性**  
    → 各コンテナは他と独立して動作（セキュリティ・依存関係の衝突を回避）
    

---

## 4️⃣ コンテナオーケストレーション（管理）

コンテナは単体でも使えるが、大規模になると管理が難しいため「オーケストレーション」が必要。

- **Amazon ECS (Elastic Container Service)**  
    AWS独自のコンテナ管理サービス
    
    - Fargate（サーバーレス実行）とEC2両方に対応
        
- **Amazon EKS (Elastic Kubernetes Service)**  
    Kubernetes（オープンソース）をAWSでマネージド提供
    
- **AWS Fargate**  
    コンテナの実行基盤をサーバーレスで提供
    

---

## 5️⃣ ユースケース

- マイクロサービスアーキテクチャ（アプリを小さなサービスに分割）
    
- 継続的インテグレーション / 継続的デリバリー (CI/CD) パイプライン
    
- スケーラブルなWebアプリやAPI
    
- バッチ処理や機械学習の実行基盤
    

---

💡 **まとめ**

- コンテナ = アプリ実行に必要なものをパッケージ化した軽量な単位
    
- VMより軽量・高速で、移植性に優れる
    
- AWSでは **ECS / EKS / Fargate** がコンテナ基盤を支えるサービス
- 。

---

# 🔹 EC2 vs コンテナ vs Lambda 比較表

|観点|EC2|コンテナ (ECS/EKS/Fargate)|Lambda|
|---|---|---|---|
|**サービスモデル**|IaaS (仮想サーバー)|CaaS (コンテナ基盤)|FaaS (関数)|
|**制御範囲**|OS、ミドルウェア、アプリ全て管理|コンテナイメージと定義のみ管理|アプリコードのみ管理|
|**起動時間**|数分（AMIから）|数秒（コンテナ起動）|ミリ秒〜数秒|
|**稼働時間**|常時稼働前提|長時間稼働OK|短時間（最大15分/1実行）|
|**スケーリング**|Auto Scaling|コンテナオーケストレーション|完全自動スケーリング|
|**課金**|起動中の時間＋リソース|CPU/メモリ × 実行時間|実行時間（100ms単位）＋リクエスト数|
|**代表ユースケース**|レガシーアプリ、DB、OS制御必要|マイクロサービス、Web/API基盤、バッチ|イベント駆動処理、軽量API、トリガー|

---

# 🔹 選択基準まとめ

1. **OS管理や特殊設定が必要？**
    
    - 必要 → **EC2**
        
    - 不要 → コンテナ or Lambda
        
2. **処理時間は長い？短い？**
    
    - 長時間 → **EC2 / コンテナ**
        
    - 短時間・イベント駆動 → **Lambda**
        
3. **アプリの形態は？**
    
    - モノリシック（従来型アプリ） → **EC2**
        
    - マイクロサービス化 → **コンテナ**
        
    - 単発タスク／APIバックエンド → **Lambda**
        
4. **スケーラビリティの要件は？**
    
    - 柔軟にコンテナ単位でスケール → **ECS/EKS/Fargate**
        
    - トラフィックの急増を自動処理 → **Lambda**
        

---

# 🔹 試験対策シナリオ

## ✅ シナリオ1

**要件:** レガシーアプリケーションをそのままAWSに移行したい。アプリは特定のOSライブラリに依存。  
👉 選択肢: **EC2**  
（理由: OSレベルの制御が必要。リフト＆シフトに最適）

---

## ✅ シナリオ2

**要件:** Webアプリをマイクロサービス化し、サービスごとに独立デプロイしたい。コンテナ化は既に進んでいる。  
👉 選択肢: **ECS/EKS + Fargate**  
（理由: コンテナ基盤が最適。オーケストレーションによるスケーリングと独立管理が可能）

---

## ✅ シナリオ3

**要件:** S3に画像がアップロードされたら、自動でサムネイルを生成する仕組みを作りたい。常時サーバーは不要。  
👉 選択肢: **Lambda**  
（理由: S3イベントでトリガーでき、サーバーレスで運用管理不要）

---

## ✅ シナリオ4

**要件:** 高トラフィックなWebサイト。ピーク時のアクセス増に柔軟に対応したいが、アプリはモノリシックでコンテナ化できない。  
👉 選択肢: **EC2 + Auto Scaling + ELB**  
（理由: モノリシックアプリなのでEC2。スケーラビリティはAuto Scalingで対応）

---

## ✅ シナリオ5

**要件:** 分析用のバッチ処理を数時間単位で走らせたい。処理内容はDockerコンテナ化済み。  
👉 選択肢: **Fargate (ECS)**  
（理由: 長時間処理が必要だが、サーバーレスで運用管理を最小化できる）

---

# 💡 試験の押さえどころ

- **EC2** → レガシー移行、OS制御、常時稼働
    
- **コンテナ** → マイクロサービス、ポータビリティ、オーケストレーション
    
- **Lambda** → イベント駆動、短時間処理、完全サーバーレス